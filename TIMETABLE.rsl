NET
scheme TIMETABLE = extend NET with
class
  type 
    TimeTable = TramId -m-> Plan, -- time tables
    Entry::
	si: StopId
	at: Time
	dt: Time,
    Plan = (Entry)-list,
    TramId = Text, -- tram names
    Connection::
	s1: StopId
	s2: StopId
	c: Capacity
	t: DrivingTime

    value /* generators */
      -- the empty timetable
      empty: TimeTable,
      emptyPlan: Plan = <..>,
      
      -- add to a time table an empty plan for a new tram
      addTram: TramId >< TimeTable -> TimeTable
      addTram(ti, tt) is tt !! [ti +> emptyPlan],


      -- add a stop with arrival time and departure time to the plan for a given tram
      addStop: TramId >< StopId >< Time >< Time >< TimeTable -> TimeTable
      addStop(ti, si, t1, t2, tt) is tt !! [ti +> tt(ti) ^ <.mk_Entry(si, t1, t2).>]
      pre isIn(ti, tt)

  value /* observers */
     -- check whether a tram with a given name exists in a given time table
     isIn: TramId >< TimeTable -> Bool
     isIn(ti, tt) is ti isin dom(tt),
     
     isIn: StopId >< Plan -> Bool
     isIn(si, p) is
		   if p = emptyPlan then
		      false
		   elsif si = si(hd(p)) then
		      true
		   else
		      isIn(si, tl(p))
		   end
			   
     -- you can add more observers here
     
 
  value /* predicates to check time tables */   
     

     noEntryInPlan: TimeTable >< Net -> Bool
     noEntryInPlan(tt, n) is ~(all p : Plan :- p isin rng(tt) =>(exists si :
     StopId :- isIn(si, p) /\ ~(isIn(si, n)))),

     correctTimingAtStop: TimeTable >< Net -> Bool
     correctTimingAtStop(tt, n) is (all p : Plan :- p isin rng(tt) =>
			     ~(exists e: Entry :- e isin p /\ dt(e) - at(e) <
			     minWaitingTime(si(e), n))),

     currentState: TramId >< TimeTable >< Time -> StopId >< StopId
     currentState(ti, tt, t) is recCurrentState(tt(ti), si(hd(tt(ti))), t),

     recCurrentState: Plan >< StopId >< Time -> StopId >< StopId
     recCurrentState(p, sio,  t) is 
			  let 
			     e = hd(p)
			  in
			     if t > dt(e) then
				recCurrentState(tl(p), si(e), t)
			     elsif t >= at(e) then
			        (si(e), si(e))
			     else
			        (sio, si(e))
			     end
			  end,
     
     capacityAtStop: TimeTable >< Net -> Bool
     capacityAtStop(tt, n) is ~(exists si : StopId :- isIn(si, n) => (exists
     t : Time :- capacity(si, n) < card({ti | ti : TramId :-
     currentState(ti, tt, t) = (si, si)}))),

     capacityAtConnection: TimeTable >< Net -> Bool
     capacityAtConnection(tt, n) is ~(exists c : Connection :-
						areDirectlyConnected(s1(c), s2(c)) => 
						(exists t: Time :-
						capacity(c, n) <
						tramsInDirection(tt,
						t, s1(c), s2(c)) +
						tramsInDirection(tt,
						t, s2(c), s1(c)))),
					      
					 ------- SHORT RECORD
					 -- CONVERSION IN PROGRESS,
					 -- CURRENTLY AT THIS POINT --------

     overlappingDirection: TimeTable >< Net -> Bool
     overlappingDirection(tt, n) is ~(exists c : Connection :-
					   let
						(s1, s2, at, dt) = c
					   in
						areDirectlyConnected(s1, s2, n) =>
						(exists t : Time :-
						tramsInDirection(tt,
						t, s1, s2) > 0 /\
						tramsInDirection(tt,
						t, s2, s1) > 0)
					   end),
    
     tramsInDirection: TimeTable >< Time >< StopId >< StopId -> Nat
     tramsInDirection(tt, t, s1, s2) is card({ti | ti : TramId :-
						currentState(ti, tt,t)
						= (s1, s2)}),
     
     noStopSkip: TimeTable >< Net -> Bool
     noStopSkip(tt, n) is ~(exists p : Plan :- p isin tt =>
				   let
					(si, at, dt) = hd(p)
				   in
					recStopSkip(si, tl(p), n)
				   end),
     
     recStopSkip: StopId >< Plan >< Net -> Bool
     recStopSkip(s1, p, n) is let
				 (s2, at, dt) = if p ~= emptyPlan then
				 hd(p) end
			      in
			         if p = emptyPlan then
				    True
				 elsif ~areDirectlyConnected(s1, s2, n) then
				    False
				 else
				    recStopSkip(s2, tl(p), n)
				 end
			       end,
			       
     CorrectDrivingTime: TimeTable >< Net -> Bool
     CorrectDrivingTime(tt, n) is ~(exists p : Plan :- p isin tt =>
				  let
				     (si, at, dt) = hd(p)
				  in
				     recCorrectDrivingTime(si, dt,
				     tl(p), n)
				  end),
     
     recCorrectDrivingTime: StopId >< Time >< Plan >< Net -> Bool
     recCorrectDrivingTime(s1, t, p, n) is 
				     let
					 (s2, at, dt) = if p ~=
					 emptyPlan then  hd(p) end
				     in
					if p = emptyPlan then
					   True
				        elsif at - t < minDrivingTime(s1, s2, n) then
					   False
				        else
					   recCorrectDrivingTime(s2, dt, tl(p), n)
				        end
			             end,   

     isWellformed : TimeTable >< Net -> Bool
     isWellformed(tt, n) is 
		      noEntryInPlan(tt, n) /\
		      correctTimingAtStop(tt, n) /\ 
		      capacityAtStop(tt, n) /\
		      capacityAtConnection(tt, n) /\ 
		      overlappingDirection(tt, n) /\
		      noStopSkip(tt, n) /\ 
		      correctDrivingTime(tt, n)		 
     
end  
