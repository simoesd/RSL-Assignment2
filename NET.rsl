scheme NET =
class
  type 
 --  Net = Stop-set >< Connection-set,

   Net :: 
    stops: Stop-set
    connections: Connection-set,


  --  Stop = StopId >< Capacity >< WaitingTime,


   Stop ::
    sId: StopId
    c: Capacity
    wt: WaitingTime,


   /* Connection = StopId >< StopId >< Capacity >< DrivingTime, */

   Connection ::
    id1: StopId
    id2: StopId
    c: Capacity
    dt: DrivingTime,
    
   StopId = Text,     
   Capacity = Nat,   
   WaitingTime = Time,  
   DrivingTime = Time, 
   Time = Nat 

  value /* generators */
    empty :  Net = mk_Net({},{}),

    -- insert a stop with a given name, capacity and minimum waiting time
    insertStop : StopId >< Capacity >< WaitingTime >< Net -> Net
    insertStop(id, c, wt, n) is
      if stops(n) = {} then mk_Net(stops(n) union {mk_Stop(id, c, wt)},
        connections(n))
      elsif isIn(id, n) then n
      else mk_Net(stops(n) union  {mk_Stop(id, c, wt)}, connections(n))
      end,


  --  add a connection between given stops, 
  --  with a given capacity and a given minimum driving time 
   addConnection : StopId >< StopId >< Capacity >< DrivingTime >< Net -> Net 
   addConnection(id1, id2, c, dt, n) is
    if stops(n) = {} then n
    elsif isIn(id1, n) /\ isIn(id2, n) /\ ~areDirectlyConnected(id1,
    id2, n)
    then mk_Net(stops(n), connections(n) union {mk_Connection(id1, id2, c, dt)})
    else n
    end

    
  value /* observers */
   -- check whether a stop is in a network     
    isIn : StopId >< Net -> Bool
    isIn(stopId, n) is 
      (exists s : Stop :- s isin stops(n) /\ (sId(s) = stopId)),


   -- check whether two stops are directly connected in a network        
    areDirectlyConnected : StopId >< StopId >< Net -> Bool
    areDirectlyConnected(id1, id2, n) is 
    (
     exists c : Connection :- 
     c isin connections(n) /\ id1 = id1(c) /\ id2 = id2(c)
    ),

--    -- get the capacity of a stop 
    capacity : StopId >< Net -~-> Capacity
    capacity(stopId, n) is 
      if isIn(stopId, n) then c(stopsRecursive(stopId, stops(n))) 
      else 0 
    end,
    
    --  recursive stop traversal method
    stopsRecursive : StopId >< Stop-set -> Stop
    stopsRecursive(stopId, stops) is 
      if sId(hd(stops)) ~= stopId then stopsRecursive(stopId, stops \ {hd(stops)}) 
      else hd(stops) 
    end,
    

   -- get the minimum waiting time of a stop 
   minWaitingTime : StopId >< Net -~-> WaitingTime
   minWaitingTime(stopId, n) is 
    if isIn(stopId, n) then wt(stopsRecursive(stopId, stops(n))) 
    else 0 
   end,
   
    --  recursive stop traversal method
    stopsConnRecursive : StopId >< StopId >< Connection-set -> Connection
    stopsConnRecursive(sId1, sId2, stops) is 
      if (id1(hd(stops)) = sId1 /\ id2(hd(stops)) = sId2) 
      \/ (id1(hd(stops)) = sId2 /\ id2(hd(stops)) = sId1) 
        then stopsConnRecursive(sId1, sId2, stops \ {hd(stops)}) 
      else hd(stops) 
    end,

    isInConn : StopId >< StopId >< Net -> Bool
    isInConn(sId1, sId2, n) is 
      (exists c : Connection :- c isin connections(n) /\ (((id1(c) = sId1) 
              /\ id2(c) = sId2) \/ ((id1(c) = sId2) /\ id2(c) = sId1))),


    capacity : StopId >< StopId >< Net -~-> Capacity
    capacity(sId1, sId2, n) is 
      if isInConn(sId1, sId2, n) then c(stopsConnRecursive(sId1, sId2,
        connections(n))) 
      else 0 
    end,


--    -- get minimum driving time between two connected stops        
   minDrivingTime : StopId >< StopId >< Net -~-> DrivingTime
   minDrivingTime(sId1, sId2, n) is 
    if isInConn(sId1, sId2, n) then dt(stopsConnRecursive(sId1, sId2,
      connections(n))) 
    else 0 
   end,


  connectedBothWays : Stop >< Stop >< Connection-set -> Bool
  connectedBothWays(stop1, stop2, connections) is
    (
    exists s1, s2: Stop, c1, c2 : Connection :- c1 isin connections /\
    c2 isin connections /\ s1 = stop1 /\ s2 = stop2 /\ id1(c1) = sId(s1)
    /\ id2(c1) = sId(s2) /\ id1(c2) = sId(s2) /\ id2(c2) = sId(s1)
    )

 /* predicates to check nets

  - at most one track connecting two stops.
    - NOT A->B and B->A 

--    isWellformed : Net -> Bool
--    isWellformed(n) is
        if 
        
        

--    */
end  
