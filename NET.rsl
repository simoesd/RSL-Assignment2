scheme NET =
class
  type 
   Net = Stop-set >< Connection-set,
  --  Stop = StopId >< Capacity >< WaitingTime,


   Stop ::
    sId: StopId
    c: Capacity
    wt: WaitingTime,


   /* Connection = StopId >< StopId >< Capacity >< DrivingTime, */

   Connection ::
    id1: StopId
    id2: StopId
    c: Capacity
    dt: DrivingTime,
    
   StopId = Text,     
   Capacity = Nat,   
   WaitingTime = Time,  
   DrivingTime = Time, 
   Time = Nat 

  value /* generators */
    empty :  Net = ({}, {}),

    -- insert a stop with a given name, capacity and minimum waiting time
    insertStop : StopId >< Capacity >< WaitingTime >< Net -> Net
    insertStop(id, c, wt, (stops, connections)) is
      if stops = {} then (stops union {mk_Stop(id, c, wt)}, connections)
      elsif isIn(id, (stops, connections)) then (stops, connections)
      else (stops union  {mk_Stop(id, c, wt)}, connections)
      end,


  --  add a connection between given stops, 
  --  with a given capacity and a given minimum driving time 
   addConnection : StopId >< StopId >< Capacity >< DrivingTime >< Net -> Net 
   addConnection(id1, id2, c, dt, (stops, connections)) is
    if stops = {} then (stops, connections)
    elsif isIn(id1, (stops, connections)) /\ isIn(id2, (stops,
    connections)) /\ ~areDirectlyConnected(id1, id2, (stops,connections))
    then (stops, connections union {mk_Connection(id1, id2, c, dt)})
    else (stops, connections)
    end

    
  value /* observers */
   -- check whether a stop is in a network     
    isIn : StopId >< Net -> Bool
    isIn(stopId, (stops, connections)) is 
      (exists s : Stop :- s isin stops /\ (sId(s) = stopId)),


   -- check whether two stops are directly connected in a network        
    areDirectlyConnected : StopId >< StopId >< Net -> Bool
    areDirectlyConnected(id1, id2, (stops, connections)) is 
    (
    exists c : Connection :- 
    c isin connections /\ id1 = id1(c) /\ id2 = id2(c)
    ),

--    -- get the capacity of a stop 
    capacity : StopId >< Net -~-> Capacity
    capacity(stopId, (stops, connections)) is if isIn(stopId, (stops, connections)) then c(stopsRecursive(stopId, stops)) else 0 end,
    
    --  recursive stop traversal method
    stopsRecursive : StopId >< Stop-set -> Stop
    stopsRecursive(stopId, stops) is if sId(hd(stops)) ~= stopId then stopsRecursive(stopId, stops \ {hd(stops)}) else hd(stops) end,
    

   -- get the minimum waiting time of a stop 
   minWaitingTime : StopId >< Net -~-> WaitingTime
   minWaitingTime(stopId, (stops, connections)) is if isIn(stopId, (stops, connections)) then wt(stopsRecursive(stopId, stops)) else 0 end,
   
    --  recursive stop traversal method
    stopsConnRecursive : StopId >< StopId >< Connection-set -> Connection
    stopsConnRecursive(sId1, sId2, stops) is if (id1(hd(stops)) = sId1 /\ id2(hd(stops)) = sId2) \/ (id1(hd(stops)) = sId2 /\ id2(hd(stops)) = sId1) 
    then stopsConnRecursive(sId1, sId2, stops \ {hd(stops)}) else hd(stops) end,

    isInConn : StopId >< StopId >< Net -> Bool
    isInConn(sId1, sId2, (stops, connections)) is 
      (exists c : Connection :- c isin connections /\ (((id1(c) = sId1) /\ id2(c) = sId2) \/ ((id1(c) = sId2) /\ id2(c) = sId1))),


    capacity : StopId >< StopId >< Net -~-> Capacity
    capacity(sId1, sId2, (stops, connections)) is if isInConn(sId1, sId2, (stops, connections)) then c(stopsConnRecursive(sId1, sId2, connections)) else 0 end,


--    -- get minimum driving time between two connected stops        
   minDrivingTime : StopId >< StopId >< Net -~-> DrivingTime
   minDrivingTime(sId1, sId2, (stops, connections)) is if isInConn(sId1, sId2, (stops, connections)) then dt(stopsConnRecursive(sId1, sId2, connections)) else 0 end

--  value /* predicates to check nets */
--    isWellformed : Net -> Bool
--    isWellformed(n) is ...

--    */
end  
